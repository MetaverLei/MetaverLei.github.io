<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数模中模拟退火算法的应用 | MetaverLei</title><meta name="author" content="LeLei"><meta name="copyright" content="LeLei"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="问题引入关于路径距离优化的思考(1)一个旅人需要访问 4 个城市，从 A 城市出发，可选择不同顺序依次访问每个城市，最后回到出发城市。他想找到一条总路程最短的路径。使用两点间距离公式计算两城市之间的距离。如果把地图拿到一个二维坐标系XOY 里面，那么城市的坐标如下：  城市 A: (0, 0) 城市 B: (2, 3) 城市 C: (5, 1) 城市 D: (6, 4)  (2) 当城市数量增加到">
<meta property="og:type" content="article">
<meta property="og:title" content="数模中模拟退火算法的应用">
<meta property="og:url" content="http://example.com/2024/10/06/simulanneal/index.html">
<meta property="og:site_name" content="MetaverLei">
<meta property="og:description" content="问题引入关于路径距离优化的思考(1)一个旅人需要访问 4 个城市，从 A 城市出发，可选择不同顺序依次访问每个城市，最后回到出发城市。他想找到一条总路程最短的路径。使用两点间距离公式计算两城市之间的距离。如果把地图拿到一个二维坐标系XOY 里面，那么城市的坐标如下：  城市 A: (0, 0) 城市 B: (2, 3) 城市 C: (5, 1) 城市 D: (6, 4)  (2) 当城市数量增加到">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/covers/OIP-C.jpg">
<meta property="article:published_time" content="2024-10-06T07:28:09.000Z">
<meta property="article:modified_time" content="2024-10-09T14:12:52.578Z">
<meta property="article:author" content="LeLei">
<meta property="article:tag" content="模拟退火">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/covers/OIP-C.jpg"><link rel="shortcut icon" href="/img/favicon1.png"><link rel="canonical" href="http://example.com/2024/10/06/simulanneal/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数模中模拟退火算法的应用',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-09 22:12:52'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/topimg/study.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="MetaverLei"><span class="site-name">MetaverLei</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数模中模拟退火算法的应用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-06T07:28:09.000Z" title="发表于 2024-10-06 15:28:09">2024-10-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-09T14:12:52.578Z" title="更新于 2024-10-09 22:12:52">2024-10-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%A8%A1/">数模</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数模中模拟退火算法的应用"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h1><h2 id="关于路径距离优化的思考"><a href="#关于路径距离优化的思考" class="headerlink" title="关于路径距离优化的思考"></a>关于路径距离优化的思考</h2><p>(1)一个旅人需要访问 4 个城市，从 A 城市出发，可选择不同顺序依次访问每个城市，最后回到出发城市。他想找到一条总路程最短的路径。使用两点间距离公式计算两城市之间的距离。<br>如果把地图拿到一个二维坐标系XOY 里面，那么城市的坐标如下：</p>
<ul>
<li>城市 A: (0, 0)</li>
<li>城市 B: (2, 3)</li>
<li>城市 C: (5, 1)</li>
<li>城市 D: (6, 4)</li>
</ul>
<p>(2) 当城市数量增加到 10，我们就需要考虑借助计算机解决该问题了。</p>
<p>(3) 当城市数量 N&#x3D;32 或者更大时，考虑下面的算法：</p>
<ol>
<li>设置初始“解”：随机生成一条城市的访问顺序作为初始的访问路径，如:A-B-C-D-E-F-A。</li>
<li>设定优化的目标：计算当前路径的总距离，这个距离不一定是最短的，毕竟是随便选的嘛。不过，我们可以把这个距离作为后面优化的目标。</li>
<li>“邻域解 ”的生成和距离的优化：通过随机交换对任意两座城市的访问顺序生成新的路径。例如，如果原来的访问顺序是A-B-C-D-E-F-A，那么，随机交换之后的一个可能的访问顺序就是A-C-B-D-E-F-A。由于新旧路径中只有两个城市的访问顺序不同，其它地方都是相同的，因此我们认为它们是差不多的、相近的解，即“邻域解”。然后，计算新路径的总距离，看看是否变短了。如果新路径的总距离变短了，就接受它，把它作为新的解。</li>
<li>温度和接受准则：设置起始“温度 ”值和温度降低的速度值。计算机刚开始执行程序时，“温度 ”的数值较高，后面随着算法的进行，“温度”逐渐降低。即使交换两个城市的访问顺序之后的新路径变长了，我们仍然以一定概率接受它。温度越高时，这个概率越高。</li>
</ol>
<p><strong>问题：</strong></p>
<ol>
<li><p><strong>该算法名为模拟退火算法，对比该算法与随机选取路径、穷举所有路径的效果。当城市数量 N 非常大的时候，采用该算法有什么好处？</strong></p>
</li>
<li><p><strong>每一次生成新的路径，如果新路径与原路径相比更短，将它作为新的解是可以理解的。但是为什么即使新路径变长了，我们还要以一定概率去接受它？</strong></p>
</li>
<li><p><strong>联系问题 2，观察如下函数曲线图：</strong></p>
<p> <img src="/img/blogimg/SA1.png" alt="图一"></p>
<p> 如果我们的优化目标不再是本题中描述的改变路径、使得距离最短，而是变成了改变横坐标x、使得上图中函数的 y 值最小，那么我们应该怎么随机选取邻域解来更新x？如果算法选取了 B 点对应的x，我们就会发现，在 B 点周围的区域，选取其它的x，它们对应的 y 值都比 B 点大，那么 B 点所对应的x 就是最终的解吗？如果B点对应的x不是最终的解，那么哪一点对应的x才是最终的解？如果算法在某一时刻找到了B点，那么它随后在B点周围找的邻域解都会不如B点。此时，应该怎么做才能找到真正的最终的解？</p>
<blockquote>
<p>类比y值的优化和路径距离的优化问题，思考：想要找到真正的最终的解，算法在进行的过程中都需要做出什么样的妥协？如果同学们没看懂题目中对算法的描述，可以根据问题的启发来思考。</p>
</blockquote>
</li>
</ol>
<h1 id="思路讲解"><a href="#思路讲解" class="headerlink" title="思路讲解"></a>思路讲解</h1><ol>
<li><p><strong>该算法名为模拟退火算法，对比该算法与随机选取路径、穷举所有路径的效果。当城市数量 N 非常大的时候，采用该算法有什么好处？</strong></p>
<p> 随机选取路径的算法虽然比较简单直接，但选取的路径质量可能会比较差，有极小的概率能够选取一条相对较短的路径，但是更大的概率是选到了一些比较长的路径，<strong>不能保证结果的质量</strong>。</p>
<p> 穷举法即穷举所有路径，计算每一路径的长度的数值，然后将这些数互相比较，筛选出最小的数，这个数对应的路径即为最终的路径。这种方法的结果的质量是可以保证的，因为穷举所有情况，一定会找到最优的情况。但由于随着城市数量 N 的增加，计算机的计算量会变得特别地大。我们可以计算一下 N 对应的计算量：选取第一个城市时，有 N 种选择，选取第二个城市时，有 N-1 种选择，则选取路径的方案共有N*(N-1)<em>(N-2)</em>……<em>2</em>1&#x3D;N! 种。学习过微积分第一章极限的同学可能知道，阶乘函数的增长率甚至大于指数函数的增长率，这就意味着，当 N 的数量很大时，我们的选择数大得可怕，计算机恐怕也难以承受，<strong>效率低</strong>。</p>
<p> <strong>模拟退火算法兼具了二者的优点，并避开了二者的缺陷</strong>。</p>
<p> 与随机选取路径的算法相比，模拟退火算法对路径的选取是具有<strong>方向性的</strong>。所谓方向性，是指模拟退火算法的总体趋势是不断地用更短的路径更新原有路径，通过一次次地更新，找到的路径是趋向于越来越短的。模拟退火算法在进行过程中，趋势是朝着好的方向发展，这样能够保证最后的路径肯定是相对较短的，<strong>保证了结果质量</strong>。</p>
<p> 与穷举法相比，模拟退火算法避免了计算量随城市数量呈指数增长的问题，适合处理大量数据的情况。模拟退火算法不会把所有可能的情况都列出来，而是会从中有方向性的选取某一部分情况，这一部分情况相比所有情况只是很小的一部分，<strong>这样大大降低了计算量，提升了效率</strong>。</p>
</li>
<li><p><strong>每一次生成新的路径，如果新路径与原路径相比更短，将它作为新的解是可以理解的。但是为什么即使新路径变长了，我们还要以一定概率去接受它？</strong></p>
</li>
<li><p><strong>类比 y 值的优化和路径距离的优化问题，思考：想要找到真正的最终的解，算法在进行的过程中都需要做出什么样的妥协？</strong></p>
<p> <img src="/img/blogimg/SA1.png" alt="图一"></p>
<p> 在最小化 y 值的过程中，观察图像，我们可以看到，实际上我们想要的真正的最终的解应该是整个函数的最小值点，也就是 C 点。而 B 点只是极小值点，也就是局部的最小值点，并不是整个函数的最小值点。<strong>它是局部的最小，不是全局的最小</strong>。</p>
<p> 如果我们限定：新的 x 对应的 y 值必须比上一个 x 的 y 值更小，我们才能选取新的 x，抛弃旧的 x。那么，在这一条件下，会出现一个问题：如果算法在某一时刻找到了 B 点对应的 x，那么算法下一步在 B 点周围的邻域选取的所有 x 对应的 y 值都会比 B 点对应的 y 值大，那么条件就不会允许选取新的 x，我们最终还是会回到 B 点。可是，B 点并不是我们想要的解，很明显，C 点的 y 值更小，C 点比 B 点更好，我们更想要 C 点这个全局最优解，而不是B 点这个局部最优解。</p>
<p> 为了解决这一问题，我们做出妥协。我们可以让算法在选取 x 的过程中，不再强制要求每一次的 y 值都必须比上一次的 y 值更小。在这样的情况下，如果算法在某一时刻找到了 B点，它下一刻如果选取了 B 点右侧的某一个 x，虽然这一 x 对应的 y 变大了，但是我们还是可以选择这个 x。如果上述情况发生了多次，那么我们选取的 x 会不断向右移动，直到“逾越”B 点右侧的“高峰”，落入 C 点周围的“低谷”。这样，算法就有机会选择到 C 点了。</p>
<p> 总之，为了找到全局的最优解，我们需要做出妥协，<strong>即面对更差的解</strong>，<strong>我们也可能会选择它，因为虽然当下我们选择了更差的解，但这一选择却为未来选择更优的解提供了机会与可能性。暂时的妥协，换来的可能是更优的最终结果</strong>。</p>
<p> 当然，我们不能无节制地让算法选取更高的 y 值，因为如果算法面对更高的 y 值也一定会接受，选取更低的 y 值也一定会接受，那么算法就丧失了选择的方向性，和随机生成路径没有本质的区别了。我们每一次面对更高的 y 值，应该以一定概率去接受它，而不是无节制地接受。比如，我们设置接受更高的 y 值的概率为 0.6，那么我们每次面对更高的 y 值时，都有 0.4 的概率不去选择它，还是退回到原来的解。可以想象：接受的概率值越大，算法选取的点越容易左右剧烈地“移动”，很难停留在某一个点；接受的概率越小，算法选取的点越稳定，找到了一个较小的点就不容易再变了。</p>
<p> 为此，我们引入了<strong>温度</strong>的概念。<strong>算法开始时，温度高，算法选取的点趋向于左右跳动，在很大范围内探索；随着算法的逐渐进行，温度逐渐降低，算法选取的点更稳定，逐渐“收敛”，在某一个点周围不怎么动了，最终就能确定这个点作为最终的解</strong>。</p>
</li>
</ol>
<h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><h2 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h2><ul>
<li>控制参数的初值$T_0$：冷却开始的温度。</li>
<li>控制参数$T$的衰减函数：因计算机能处理的都是离散数据，因此需要把连续的降温过程离散化成降温过程中的一系列温度点，衰减函数即计算这一系列温度的表达式。</li>
<li>控制参数$T$的终值$T_f$（终止准则）。</li>
<li>Markov链的长度$L_k$：任意温度$T$的迭代次数。</li>
</ul>
<h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ol>
<li>令$T&#x3D;T_0$，即开始退火的初始温度，随机生成一个初始解$x_0$，并计算相应的目标函数值E($x_0$)。</li>
<li>令$T$等于冷却进度表中的下一个值$T_i$。</li>
<li>根据当前解$x_i$进行扰动，产生一个新解$x_j$，计算相应的目标雨数值E($x_j$)，得到$\Delta E&#x3D;E(x_j)-E(x_i)$。</li>
<li>如果$\Delta E&lt;0$，则新解$x_j$被接受，作为新的当前解；如果$\Delta E&gt;0$，则新解$x_j$按概率$exp(- \Delta E&#x2F;T_i)$接受，$T$为当前温度。</li>
<li>在温度$T_i$下，重复$L_k$次的扰动和接受过程($L_k$是Markov链长度)，即步骤3、4。</li>
<li>判断是否$T$已到达$T_f$，是，则终止算法，否，则转到步骤2继续执行。</li>
</ol>
<p>算法实质分两层循环，在任一温度随机扰动产生新解，并计算目标函数值的变化，决定是否被接受。由于算法初始温度比较高，这样，使$E$增大的新解在初始时也可能被接受，因而能跳出局部极小值，然后通过缓慢地降低温度，算法最终可能收敛到全局最优解。还有一点要说明的是，虽然在低温时接受函数已经非常小了，但仍不排除有接受更差的解的可能，因此一般都会把退火过程中碰到的最好的可行解(历史最优解)也记录下来，与终止算法前最后一个被接受解一并输出。</p>
<h2 id="算法说明"><a href="#算法说明" class="headerlink" title="算法说明"></a>算法说明</h2><p>为了更好地实现模拟退火算法，在个人的经验之外，还需要注意以下一些方面。</p>
<h3 id="状态表达"><a href="#状态表达" class="headerlink" title="状态表达"></a>状态表达</h3><p>在题中的状态表达即指:实际问题的解(即状态)如何以一种合适的数学形式被表达出来，它应当适用于SA的求解，又能充分表达实际问题，这需要仔细地设计。可以参考遗传算法和禁忌搜索中编码的相关内容。常见的表达方式有背包问题和指派问题的0-1编码、TSP问题和调度问题的自然数编码，还有用于连续两数优化的实数编码等。</p>
<h3 id="新解的产生"><a href="#新解的产生" class="headerlink" title="新解的产生"></a>新解的产生</h3><p>新解产生机制的基本要求是能够尽量遍及解空间的各个区域，这样，在某一恒定温度不断产生新解时，就可能跳出当前区域以搜家其他区城。这是模拟退火算法能够进行广城搜索的一个重要条件。</p>
<h3 id="收敛的一般性条件"><a href="#收敛的一般性条件" class="headerlink" title="收敛的一般性条件"></a>收敛的一般性条件</h3><p>收敛到全局最优的一般性条件是：</p>
<ul>
<li>初始温度足够高；</li>
<li>热平衡时间足够长；</li>
<li>终止温度足够低；</li>
<li>降温过程足够缓慢。</li>
</ul>
<p>但上述条件在应用中很难同时满足，因此还需考虑以下几方面。</p>
<h3 id="参数的选择"><a href="#参数的选择" class="headerlink" title="参数的选择"></a>参数的选择</h3><ol>
<li><p>控制参数T的初值T。<br> 求解全局优化问题的随机搜索算法一般都采用大范围的粗略搜索与局部的精细搜索相结合的搜索策略。只有在初始的大范围搜索阶段找到全局最优解所在的区域，才能逐渐缩小按索的范围，最终求出全局最优解。模拟退火算法是通过控制参数$T$的初值$T_0$。及其衰减变化过程来实现大范围的粗略搜索与局部的精细搜索的。一般来说，只有足够大的$T_0$。才能满足算法要求(但对不同的问题，“足够大”的含义也不同，有的可能$T_0&#x3D;100$就可以，有的则要更高)。在问题规模较大时，过小的$T$。往往导致算法难以跳出局部陷阱而达不到全局最优，但为了减少计算量，$T_0$不宜取得过大，而应与其他参数折中选取。</p>
</li>
<li><p>控制参数T的衰减函数<br> 衰减函数可以有多种形式，一个常用的衰减函数是:</p>
<p> $$T_{k+1}&#x3D;\alpha T, (k&#x3D;0,1,2…)$$</p>
<p> 其中，$\alpha$是一个常数，可以取为0.5~0.9，它的取值决定了降温的过程。</p>
<p> 小的衰减量可能导致算法进程选代次数的增加，从而使算法进程接受更多的变换，访问更多的邻域，搜索更大范围的解空间，返回更好的最终解。同时，由于在$T_k$值上已经达到准平衡，所以在$T_{k+1}$时只需少量的变换就可达到准平衡。这样就可选取较短长度的Markov链来减少算法时间。</p>
</li>
<li><p>Markov链长度<br> Markov链长度的选取原则:在控制参数$T$的衰减丽数已选定的前提下，$L_k$应能使在控制参数$T$的每一取值上达到准平衡。从经验上说，对于简单的情况，可以令$L_k&#x3D;100n$，$n$为问题规模。</p>
</li>
</ol>
<h3 id="算法停止准则"><a href="#算法停止准则" class="headerlink" title="算法停止准则"></a>算法停止准则</h3><p>对Metropolis准则中的接受函数$exp[{-(E_j-E-i)}&#x2F;{k*t}]$进行分析可知，在$T$比较大的高温情况，指数上的分母比较大，而这是一个负指数，所以整个接受丽数可能会趋于1，即比当前解工更差的新解工;也可能被接受;因此就有可能跳出局部极小而进行广域搜索，去搜索解空间的了，即难以接受比当前解更差的解，也就是不太容易跳出当前的区域。如果在高温时已经进行了充分的广城搜索，找到了可能存在的最好解的区域，而在低温再进行足够的局部搜索，则可其他区域。而随着冷却的进行，T减小到一个比较小的值时，接受雨数分母小了，整体也小能最终找到全局最优了。</p>
<p>因此，一般$T$，设为一个足够小的正数，比如0.01~5，但这只是一个粗糙的经验，更精细的设置及其他的终止准则需要根据具体的问题做进一步的研究后再设定。  </p>
<p>以下是该流程的简要示意图：</p>
<p><img src="/img/blogimg/simulated-annealing.gif" alt="示意图"></p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line">a = <span class="number">0.99</span>;   <span class="comment">% 衰减常数，决定降温过程</span></span><br><span class="line">t0 = <span class="number">97</span>;    <span class="comment">% 退火开始温度</span></span><br><span class="line">tf = <span class="number">3</span>;     <span class="comment">% 终止温度值</span></span><br><span class="line">t = t0;     <span class="comment">% 当前温度</span></span><br><span class="line">Markov_length = <span class="number">1000</span>;  <span class="comment">% Markov链长度（任意温度T的迭代次数）</span></span><br><span class="line"></span><br><span class="line">coordinates = xlsread(<span class="string">&quot;城市信息.xlsx&quot;</span>, <span class="string">&quot;Sheet1&quot;</span>);</span><br><span class="line">coordinates(:, <span class="number">1</span>) = [];         <span class="comment">% 删除编号列</span></span><br><span class="line">amount = <span class="built_in">size</span>(coordinates, <span class="number">1</span>);  <span class="comment">% 城市数目</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 通过向量化的方法计算距离矩阵</span></span><br><span class="line">dist_matrix = <span class="built_in">zeros</span>(amount, amount);</span><br><span class="line">coor_x_tmp1 = coordinates(:, <span class="number">1</span>) * <span class="built_in">ones</span>(<span class="number">1</span>, amount);</span><br><span class="line">coor_x_tmp2 = coor_x_tmp1&#x27;;</span><br><span class="line">coor_y_tmp1 = coordinates(:, <span class="number">2</span>) * <span class="built_in">ones</span>(<span class="number">1</span>, amount);</span><br><span class="line">coor_y_tmp2 = coor_y_tmp1&#x27;;</span><br><span class="line">dist_matrix = <span class="built_in">sqrt</span>((coor_x_tmp1 - coor_x_tmp2).^<span class="number">2</span> + (coor_y_tmp1 - coor_y_tmp2).^<span class="number">2</span>);</span><br><span class="line">sol_new = <span class="number">1</span>:amount;     <span class="comment">% 方案每次的新解</span></span><br><span class="line">sol_current = sol_new;  <span class="comment">% 当前解</span></span><br><span class="line">sol_best = sol_new;     <span class="comment">% 冷却中的最优解</span></span><br><span class="line">E_new = <span class="built_in">inf</span>;            <span class="comment">% 回路距离新解</span></span><br><span class="line">E_current = <span class="built_in">inf</span>;        <span class="comment">% 距离当前解</span></span><br><span class="line">E_best = <span class="built_in">inf</span>;           <span class="comment">% 距离最优解</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> t &gt;= tf</span><br><span class="line">    <span class="keyword">for</span> r = <span class="number">1</span> : Markov_length</span><br><span class="line">        <span class="comment">% 产生随机扰动，随机决定两交换与三交换</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">rand</span> &lt; <span class="number">0.5</span>)  <span class="comment">% 两交换</span></span><br><span class="line">            ind1 = <span class="number">0</span>; ind2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(ind1 == ind2)</span><br><span class="line">                ind1 = <span class="built_in">ceil</span>(<span class="built_in">rand</span>.*amount);</span><br><span class="line">                ind2 = <span class="built_in">ceil</span>(<span class="built_in">rand</span>.*amount);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            tmp1 = sol_new(ind1);</span><br><span class="line">            sol_new(ind1) = sol_new(ind2);</span><br><span class="line">            sol_new(ind2) = tmp1;</span><br><span class="line">        <span class="keyword">else</span>            <span class="comment">% 三交换</span></span><br><span class="line">            ind1 = <span class="number">0</span>; ind2 = <span class="number">0</span>; ind3 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (ind1 == ind2) || (ind1 == ind3) || (ind2 == ind3) || (<span class="built_in">abs</span>(ind1 - ind2) == <span class="number">1</span>)</span><br><span class="line">                ind1 = <span class="built_in">ceil</span>(<span class="built_in">rand</span>.*amount);</span><br><span class="line">                ind2 = <span class="built_in">ceil</span>(<span class="built_in">rand</span>.*amount);</span><br><span class="line">                ind3 = <span class="built_in">ceil</span>(<span class="built_in">rand</span>.*amount);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            tmp1 = ind1; tmp2 = ind2; tmp3 = ind3;</span><br><span class="line">            <span class="comment">% 保证ind1&lt;ind2&lt;ind3</span></span><br><span class="line">			<span class="keyword">if</span> (ind1 &lt; ind3) &amp;&amp; (ind3 &lt; ind2)</span><br><span class="line">				ind2 = tmp3;ind3 = tmp2;</span><br><span class="line">			<span class="keyword">elseif</span> (ind2 &lt; ind1) &amp;&amp; (ind1 &lt; ind3)</span><br><span class="line">				ind1 = tmp2;ind2 = tmp1;</span><br><span class="line">			<span class="keyword">elseif</span> (ind2 &lt; ind3) &amp;&amp; (ind3 &lt; ind1) </span><br><span class="line">				ind1 = tmp2;ind2 = tmp3; ind3 = tmp1;</span><br><span class="line">			<span class="keyword">elseif</span> (ind3 &lt; ind1) &amp;&amp; (ind1 &lt; ind2)</span><br><span class="line">				ind1 = tmp3;ind2 = tmp1; ind3 = tmp2;</span><br><span class="line">			<span class="keyword">elseif</span> (ind3 &lt; ind2) &amp;&amp; (ind2 &lt; ind1)</span><br><span class="line">				ind1 = tmp3;ind2 = tmp2; ind3 = tmp1;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			</span><br><span class="line">			tmplist1 = sol_new((ind1+<span class="number">1</span>):(ind2<span class="number">-1</span>));</span><br><span class="line">			sol_new((ind1+<span class="number">1</span>):(ind1+ind3-ind2+<span class="number">1</span>)) = sol_new((ind2):(ind3));</span><br><span class="line">			sol_new((ind1+ind3-ind2+<span class="number">2</span>):ind3) = tmplist1;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">% 计算目标函数值（即内能）</span></span><br><span class="line">		E_new = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : (amount<span class="number">-1</span>)</span><br><span class="line">			E_new = E_new + ...</span><br><span class="line">				dist_matrix(sol_new(<span class="built_in">i</span>),sol_new(<span class="built_in">i</span>+<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="comment">% 再算上从最后一个城市到第一个城市的距离</span></span><br><span class="line">		E_new = E_new + ...</span><br><span class="line">			dist_matrix(sol_new(amount),sol_new(<span class="number">1</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> E_new &lt; E_current</span><br><span class="line">			E_current = E_new;</span><br><span class="line">			sol_current = sol_new;</span><br><span class="line">			<span class="keyword">if</span> E_new &lt; E_best   <span class="comment">% 把冷却过程中最好的解保存下来</span></span><br><span class="line">				E_best = E_new;</span><br><span class="line">				sol_best = sol_new;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="comment">% 若新解的目标函数值小于当前解的，</span></span><br><span class="line">			<span class="comment">% 则仅以一定概率接受新解</span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">rand</span> &lt; <span class="built_in">exp</span>(-(E_new-E_current)./t)</span><br><span class="line">				E_current = E_new;</span><br><span class="line">				sol_current = sol_new;</span><br><span class="line">			<span class="keyword">else</span>	</span><br><span class="line">				sol_new = sol_current;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	t=t.*a;		<span class="comment">% 控制参数t（温度）减少为原来的a倍</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 重新排列最优方案</span></span><br><span class="line">route_begin = <span class="number">1</span>;    <span class="comment">% 指定起始点</span></span><br><span class="line">split_index = <span class="built_in">find</span>(sol_best == route_begin, <span class="number">1</span>);</span><br><span class="line">new_sol_best = [sol_best(split_index:<span class="keyword">end</span>), sol_best(<span class="number">1</span>:split_index<span class="number">-1</span>)];</span><br><span class="line"></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;最优解为：&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(new_sol_best)</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;最短距离：&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(E_best)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em>参考资料：MATLAB数学建模方法与实践（第3版） 卓金武、王鸿钧<strong>编著</strong></em></p>
</blockquote>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/">模拟退火</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="/img/covers/OIP-C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/09/maotai-cake/" title="酱香饼的绝佳配方"><img class="cover" src="/img/covers/mtcake.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">酱香饼的绝佳配方</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/12/buildmyblog/" title="第一篇博客——关于我如何建立的这个网站"><img class="cover" src="/img/covers/hexo.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第一篇博客——关于我如何建立的这个网站</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC82MDE3My8zNjY0MQ=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">LeLei</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/MetaverLei"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎欢迎QWQ</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5"><span class="toc-number">1.</span> <span class="toc-text">问题引入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E8%B7%AF%E5%BE%84%E8%B7%9D%E7%A6%BB%E4%BC%98%E5%8C%96%E7%9A%84%E6%80%9D%E8%80%83"><span class="toc-number">1.1.</span> <span class="toc-text">关于路径距离优化的思考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E8%AE%B2%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">思路讲解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.</span> <span class="toc-text">算法步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E8%AF%B4%E6%98%8E"><span class="toc-number">3.1.</span> <span class="toc-text">符号说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.2.</span> <span class="toc-text">基本步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AF%B4%E6%98%8E"><span class="toc-number">3.3.</span> <span class="toc-text">算法说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%A1%A8%E8%BE%BE"><span class="toc-number">3.3.1.</span> <span class="toc-text">状态表达</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E8%A7%A3%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="toc-number">3.3.2.</span> <span class="toc-text">新解的产生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B6%E6%95%9B%E7%9A%84%E4%B8%80%E8%88%AC%E6%80%A7%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.3.3.</span> <span class="toc-text">收敛的一般性条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">3.3.4.</span> <span class="toc-text">参数的选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%81%9C%E6%AD%A2%E5%87%86%E5%88%99"><span class="toc-number">3.3.5.</span> <span class="toc-text">算法停止准则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81"><span class="toc-number">4.</span> <span class="toc-text">参考代码</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/10/09/maotai-cake/" title="酱香饼的绝佳配方"><img src="/img/covers/mtcake.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="酱香饼的绝佳配方"/></a><div class="content"><a class="title" href="/2024/10/09/maotai-cake/" title="酱香饼的绝佳配方">酱香饼的绝佳配方</a><time datetime="2024-10-09T13:18:23.000Z" title="发表于 2024-10-09 21:18:23">2024-10-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/06/simulanneal/" title="数模中模拟退火算法的应用"><img src="/img/covers/OIP-C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数模中模拟退火算法的应用"/></a><div class="content"><a class="title" href="/2024/10/06/simulanneal/" title="数模中模拟退火算法的应用">数模中模拟退火算法的应用</a><time datetime="2024-10-06T07:28:09.000Z" title="发表于 2024-10-06 15:28:09">2024-10-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/12/buildmyblog/" title="第一篇博客——关于我如何建立的这个网站"><img src="/img/covers/hexo.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第一篇博客——关于我如何建立的这个网站"/></a><div class="content"><a class="title" href="/2024/09/12/buildmyblog/" title="第一篇博客——关于我如何建立的这个网站">第一篇博客——关于我如何建立的这个网站</a><time datetime="2024-09-12T07:10:09.000Z" title="发表于 2024-09-12 15:10:09">2024-09-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/topimg/study.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2024 By LeLei</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(()=>{
  const loadLivere = () => {
    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if ('Livere' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>